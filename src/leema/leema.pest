
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
int = @{ ASCII_DIGIT+ }
number = _{ float | int }

strchar = { !"\"" ~ !"$" ~ !"\\" ~ ANY }
stresc = @{ "\\n" | "\\\"" | "\\" }
strlit = @{ strchar+ }
strid = _{ "$" ~ id }
strx = _{ "${" ~ expr ~ "}" }
str = ${ "\"" ~ (stresc | strlit | strid | strx )* ~ "\"" }

negative = { "-" }
plus = { "+" }
dash = { "-" }
star = { "*" }
slash = { "/" }
tick = { "'" }
dot = { "." }
modulo = { "modulo" }
and = { "and" }
or = { "or" }
not = { "not" }
less_than = { "<=" | "<" }
equality = { "==" | "!=" }
greater_than = { ">=" | ">" }
add_newline = { "\\n" }
underscore = { "_" }
block_arrow = _{ "->" | ">>" }
double_dash = _{ "--" }

prefix_op = _{
    negative
    | not
    | star
}

postfix_op = _{
    (as1 ~ add_newline)
    | tuple
}

// keywords
func_mode = { "func" | "macro" }
let_mode = { "let" | "const" }
rust_block = { "-RUST-" }
mxport = { "import" | "export" }

infix_op = _{
    star | slash | modulo
    | plus
    | less_than | equality | greater_than
    | and | or
}

spaced_infix_op = _{
    (as1 ~ infix_op ~ as1)
    | (hs1 ~ dash ~ as1)
    | as0 ~ dot ~ as0
    | tick
}

keywords = _{
    func_mode
    | mxport
    | "datatype"
    | "match" | "if"
    | and | or | not
}

keyword_prefix = _{
    keywords ~ ( LETTER | NUMBER | "_" )+
}

// horizontal space only
hs0 = _{ " "* }
hs1 = _{ " "+ }
// any horizontal or vertical space
as0 = _{ (" " | NEWLINE)* }
as1 = _{ (" " | NEWLINE)+ }
// vertical space required
vs1 = _{ NEWLINE ~ as0 }

modname_tail = _{ ASCII_ALPHA_LOWER | ASCII_DIGIT }
modname = @{ !keywords ~ ASCII_ALPHA_LOWER ~ modname_tail* }

id = @{
    keyword_prefix
    | !keywords ~ ((LETTER | "_") ~ ( LETTER | NUMBER | "_" )* | "#")
}
def_generic = { id ~ ("'" ~ id)+ }
def_id = _{ def_generic | id }

hashtag = @{ "#" ~ id }

term = _{ hashtag | id | number | str | tuple | list }
pattern = _{ underscore | expr }

x_maybe_k = { (id ~ hs0 ~ ":" ~ as0)? ~ expr }
xlist = _{ x_maybe_k ~ (as0 ~ "," ~ as0 ~ x_maybe_k)* ~ as0 ~ ","? }
list = { "[]" | "[" ~ as0 ~ xlist? ~ as0 ~ "]" }
tuple = { "(" ~ as0 ~ xlist? ~ as0 ~ ")" }

case = { "|" ~ pattern ~ as1 ~ arrow_block }
ifx = { "if" ~ vs1 ~ case+ ~ "--" }
matchargs = { "match" ~ vs1 ~ case+ ~ "--" }
matchx = { "match" ~ hs1 ~ expr? ~ vs1 ~ case+ ~ "--" }

prefix1 = _{ prefix_op ~ as0 ~ term }
postfix1 = _{ term ~ postfix_op }
x1 = _{
    prefix1
    | postfix1
    | term
}

expr = !{
    x1 ~ (spaced_infix_op ~ x1)+
    | x1
}

compound_expr = _{
    ifx
    | matchx
    | matchargs
    | expr
}

// types

list_type = { "[" ~ typex ~ "]" }
generic_type = { id ~ ("'" ~ type_term)+ }
tuple_type = { "(" ~ (as0 ~ def_func_arg)* ~ as0 ~ ")" }

type_term = _{
    tuple_type
    | list_type
    | generic_type
    | id ~ star
    | id
}

type_func = {
    "::" ~ x_maybe_k*
    | type_term ~ "::" ~ x_maybe_k*
    | type_term ~ "::"
}

typex = { type_func | type_term }

// statements

def_func_arg = { (id ~ hs0 ~ ":" ~ as0 ~ type_term) | type_term }
def_func_args = { (hs0 ~ "::" ~ (as0 ~ def_func_arg)+)? }
def_func_result = { (as0 ~ ":" ~ type_term)? }
def_func = !{
    func_mode ~ as1 ~ def_id ~ def_func_result ~ def_func_args ~ as1 ~ func_block
}

def_struct_args = _{ def_id ~ def_func_args }
def_struct = !{ "datatype" ~ hs1 ~ def_struct_args ~ as1 ~ "--" }

def_enum_variant = { vs1 ~ "|" ~ def_struct_args }
def_enum = !{ "datatype" ~ hs1 ~ def_id ~ def_enum_variant+ ~ vs1 ~ "--" }

def_rust_type = !{ "datatype" ~ hs1 ~ id ~ as1 ~ rust_block }

let_stmt = !{ let_mode ~ hs1 ~ id ~ as1 ~ ":=" ~ as1 ~ compound_expr }

return_stmt = !{ "return" ~ as1 ~ compound_expr }

comment_line = _{ "##" ~ (!NEWLINE ~ ANY)* }

mxid = _{ "." ~ id }
mxhead = @{
    ("/" ~ modname)
    | ("../" ~ modname)
    | modname
}
mxmod = @{ mxhead ~ ("/" ~ modname)* ~ mxid? | mxid }
mxline = { mxmod ~ (hs1 ~ mxblock)? }
mxblock = !{ block_arrow ~ vs1 ~ (mxline ~ vs1)+ ~ "--" }
mxstmt = !{ mxport ~ hs1 ~ (mxline | star) }

stmt = _{
    def_func
    | def_rust_type
    | def_enum
    | def_struct
    | let_stmt
    | return_stmt
    | mxstmt
    | comment_line
    | compound_expr
}

line = _{ hs0 ~ stmt? }
stmt_block = ${ (line ~ vs1)* }
arrow_block = _{
    block_arrow ~ (hs1 ~ expr ~ vs1 | vs1 ~ stmt_block)
}
func_block = _{
    rust_block
    | (block_arrow ~ vs1 ~ stmt_block ~ double_dash)
    | (block_arrow ~ hs1 ~ expr ~ hs1 ~ double_dash)
}
file = ${ (line ~ "\n")* ~ line ~ "\n"? ~ EOI }
