
import /json
import /map
import /option
import /io.print


datatype User
    id:Int
    name:Str
--

#>>
func serialize[User](u: User): serial::Val
>>
    s = serial::ize(s, u.id)
    s = serial::ize(s, u.name)
--

func deserialize[User](d: serial::Val): User
>>
    let id := dessert::deserialize[Int](d, "id")
    let name := dessert::deserialize[Str](d, "name")
    let addr := dessert::deserialize[Address](d, "addr")
    let id := serial::get_field[Int](v, "id")
    let name := serial::get_field[Str](v, "name")
    let addr := serial::get_field[Address](v, "addr")
    User(id, name)
--

func json_deserialize[T](d: Deserializer, fldname: Str): T
>>
    let fldval := json::get_field(d, fldname)
    json::from_val[T](fldval)
--

func json_decode[T](input: Str): T
>>
    let jsonval := json::decode_val(input)
    let d := json::new_deserializer(jsonval)
    dessert::deserialize[T](d)
--

func json_encode[T](input: T): Str
>>
    let s = json::new_serializer()
    dessert::serialize[T](input, s)
    s.to_string()
#--

func user_from_json
    juser: json::Val
>>
    let fields := json::object_fields(juser)
    let id := json::int_val(option::unwrap(map::get(fields, "id")))
    let name := json::str_val(option::unwrap(map::get(fields, "name")))
    User(id, name)
--

func test_decode >>
    let s := json::decode[Str]("\"coded  '\"")
    let i := json::decode[Int]("9")
    let b := json::decode[Bool]("true")
    println("$s $i or $b")
--

func test_decode_val >>
    let ju := json::decode_val("{\"id\": 8, \"name\": \"Gerald\"}")
    let u := user_from_json(ju)
    println("$u")
--

func test_encode >>
    println(json::encode(6))
    println(json::encode(False))
    print(json::encode("hello") \n)
    print(json::encode(#world) \n)
    print(json::encode(["a", "b"]) \n)
    ## let m := map::set({}, "x", 4)
    ## print(json::encode(m) \n)
    let u := User(4, "Javier")
    println(json::encode(u))
--

func main >>
    test_encode()
    test_decode()
    test_decode_val()
--
