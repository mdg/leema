
import /list
import /map
import /option


func encode'T:Str :: val:T -RUST-
func decode'T:T :: input:Str -RUST-

datatype Val
|Integer :: Int
|String :: Str
|Boolean :: Bool
|Array :: [Val]
|Object :: {Str:Val}
|Null
--

func decode'T:T :: input:Str ->
    let jsonval := decode_val(input)
    let d := json::new_deserializer(jsonval)
    dessert::deserialize[T](d)
--

func decode_val:Val :: input:Str -RUST-

func decode_obj:{Str:Val} :: input:Str -RUST-

func decode_arr:[Val] :: input:Str -RUST-

func obj_val:Val :: v:Val name:Str ->
    option::unwrap(map::get(object_fields(v), name))
--

func obj_int:Int :: v:Val name:Str ->
    int_val(object_val(v, name))
--

func obj_str:Str :: v:Val name:Str ->
    str_val(object_val(v, name))
--

func obj_bool:Bool :: v:Val, name:Str ->
    bool_val(object_val(v, name))
--

func obj_fields(v: Val): map::T[Str, Val] ->
    match v
    |Object(flds) >> flds
    |_ >> fail(#input_error, "json value is not an object: $v")
    --
--

func array_map[T](v: Val, transform: F(Val): T): [T]
>>
    match v
    |Array(items) >> list::map(items, transform)
    |_ >> fail(#input_error, "json value is not an array: $v")
    --
--

func bool_val:Bool :: v:Val ->
    match v
    |Boolean(b) >> b
    |_ >> fail(#input_error, "json value is not a boolean: $v")
    --
--

func int_val:Int :: v:Val ->
    match v
    |Integer(i) >> i
    |_ >> fail(#input_error, "json value is not an integer: $v")
    --
--

func str_val(v: Val): Str
>>
    match v
    |String(s) >> s
    |_ >> fail(#input_error, "json value is not a string: $v")
    --
--
